<!doctype html><html lang=en data-figures class=page><head><title>TCP 发送数据 核心流程 | My Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta name=description content="MSS 作用解析
MSS 是什么？
MSS（Maximum Segment Size，最大报文段长度）
是 TCP 协议层 中一个非常关键的参数，用来表示：
一个 TCP 报文段（Segment）中能携带的最大数据量（不包括 TCP/IP 头部）。
先看一张逻辑关系图： …"><meta name=twitter:card content="summary"><meta name=twitter:creator content><meta name=twitter:title content="TCP 发送数据 核心流程"><meta name=twitter:image content="https://songronghu.github.io/"><meta property="og:url" content="https://songronghu.github.io/posts/2025-12-03/"><meta property="og:title" content="TCP 发送数据 核心流程"><meta property="og:description" content="MSS 作用解析
MSS 是什么？
MSS（Maximum Segment Size，最大报文段长度）
是 TCP 协议层 中一个非常关键的参数，用来表示：
一个 TCP 报文段（Segment）中能携带的最大数据量（不包括 TCP/IP 头部）。
先看一张逻辑关系图： …"><meta property="og:image" content="https://songronghu.github.io/"><meta name=keywords content="Blog"><link rel=apple-touch-icon sizes=180x180 href=https://songronghu.github.io/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://songronghu.github.io/icons/favicon-32x32.png><link rel=manifest href=https://songronghu.github.io/icons/site.webmanifest><link rel=canonical href=https://songronghu.github.io/posts/2025-12-03/><link rel=preload href=https://songronghu.github.io/css/styles.dc38388a8f0b890e788bd3a99b7495d14e7d5ac4359ed3b49abeb778497863b284ad4cc7e496ef58c84139295f9bafed82f5a41345eda86bd2d429cccb7c2596.css integrity="sha512-3Dg4io8LiQ54i9Opm3SV0U59WsQ1ntO0mr63eEl4Y7KErUzH5JbvWMhBOSlfm6/tgvWkE0XtqGvS1CnMy3wllg==" as=style crossorigin=anonymous><link rel=preload href=https://songronghu.github.io/en/js/bundle.9f41e8957746dbf4000a4ae0202eee34b28fe11dddf9f34fa79df3b517193fdf6bcc548f3b5eebbd24d9fdb6a28b171d1eb864b71df27f3466ad183206aa8af4.js as=script integrity="sha512-n0HolXdG2/QACkrgIC7uNLKP4R3d+fNPp53ztRcZP99rzFSPO17rvSTZ/baiixcdHrhktx3yfzRmrRgyBqqK9A==" crossorigin=anonymous><link rel=stylesheet type=text/css href=https://songronghu.github.io/css/styles.dc38388a8f0b890e788bd3a99b7495d14e7d5ac4359ed3b49abeb778497863b284ad4cc7e496ef58c84139295f9bafed82f5a41345eda86bd2d429cccb7c2596.css integrity="sha512-3Dg4io8LiQ54i9Opm3SV0U59WsQ1ntO0mr63eEl4Y7KErUzH5JbvWMhBOSlfm6/tgvWkE0XtqGvS1CnMy3wllg==" crossorigin=anonymous></head><body data-code=100 data-lines=false id=documentTop data-lang=en><header class=nav_header><nav class=nav><a href=https://songronghu.github.io/ class="nav_brand nav_item" title="My Blog">My Blog<div class=nav_close><div><svg class="icon"><title>open-menu</title><use xlink:href="#open-menu"/></svg>
<svg class="icon"><title>closeme</title><use xlink:href="#closeme"/></svg></div></div></a><div class='nav_body nav_body_left'><div class=follow><div class=color_mode><input type=checkbox class=color_choice id=mode></div></div></div></nav></header><main><div class="grid-inverse wrap content"><article class=post_content><h1 class=post_title>TCP 发送数据 核心流程</h1><div class=post_meta><span><svg class="icon"><title>calendar</title><use xlink:href="#calendar"/></svg>
</span><span class=post_date>Dec 3, 2025
</span><span class=post_time>· 9 min read</span><span>&nbsp;· <a href=https://songronghu.github.io/tags/blog/ title=Blog class="post_tag button button_translucent">Blog
</a></span><span class=page_only>&nbsp;·<div class=post_share>Share on:
<a href="https://twitter.com/intent/tweet?text=TCP%20%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%20%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b&url=https%3a%2f%2fsongronghu.github.io%2fposts%2f2025-12-03%2f&tw_p=tweetbutton" class=twitter title="Share on Twitter" target=_blank rel=nofollow><svg class="icon"><title>twitter</title><use xlink:href="#twitter"/></svg>
</a><a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fsongronghu.github.io%2fposts%2f2025-12-03%2f&t=TCP%20%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%20%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b" class=facebook title="Share on Facebook" target=_blank rel=nofollow><svg class="icon"><title>facebook</title><use xlink:href="#facebook"/></svg>
</a><a href=#linkedinshare id=linkedinshare class=linkedin title="Share on LinkedIn" rel=nofollow><svg class="icon"><title>linkedin</title><use xlink:href="#linkedin"/></svg>
</a><a href=https://songronghu.github.io/posts/2025-12-03/ title="Copy Link" class="link link_yank"><svg class="icon"><title>copy</title><use xlink:href="#copy"/></svg></a></div></span></div><div class=post_toc><h2>Overview</h2><nav id=TableOfContents><ul><li><a href=#mss-作用解析>MSS 作用解析</a><ul><li><a href=#mss-是什么>MSS 是什么？</a></li><li><a href=#mss-的作用>MSS 的作用</a></li><li><a href=#特殊场景示例>特殊场景示例</a></li></ul></li><li><a href=#rtt-是什么>RTT 是什么？</a></li><li><a href=#rtt-的作用>RTT 的作用</a><ul><li><a href=#tcp-根据-rtt-来判断超时重传-rto-rtt-系数>TCP 根据 RTT 来判断超时重传（RTO = RTT × 系数）；</a></li><li><a href=#拥塞控制算法以-rtt-为-一个循环单位>拥塞控制算法以 RTT 为“一个循环单位”：</a></li></ul></li><li><a href=#ssthresh-是什么>ssthresh 是什么？</a><ul><li><a href=#一旦网络发生拥塞-丢包或超时>一旦网络发生拥塞（丢包或超时）：</a></li></ul></li><li><a href=#cwnd-是什么>cwnd 是什么？</a></li><li><a href=#慢启动阶段-slow-start>慢启动阶段（Slow Start）</a></li><li><a href=#拥塞避免阶段-congestion-avoidance>拥塞避免阶段（Congestion Avoidance）</a><ul><li><a href=#原理>原理</a></li><li><a href=#过程>过程</a></li></ul></li><li><a href=#cwnd增长过程>cwnd增长过程</a></li><li><a href=#rtt-cwnd-ssthresh-总结对比>RTT,cwnd,ssthresh 总结对比</a></li><li><a href=#什么是-ack-与-重复的-ack>什么是 ACK 与“重复的 ACK”</a><ul><li><a href=#ack-确认报文-用来告诉发送方-我已经收到了某个序号之前的所有字节数据>ACK（确认报文） 用来告诉发送方：“我已经收到了某个序号之前的所有字节数据。”</a></li><li><a href=#ack-的值是下一个期望收到的字节序号-即-cumulative-ack-累积确认>ACK 的值是下一个期望收到的字节序号（即 cumulative ACK，累积确认）。</a></li><li><a href=#什么是-三次重复-ack>什么是“三次重复 ACK”</a></li><li><a href=#为什么-三次-是阈值>为什么“三次”是阈值？</a></li><li><a href=#如果只是一个包被延迟-可能导致一两次重复-ack>如果只是一个包被延迟，可能导致一两次重复 ACK；</a></li><li><a href=#但若出现-三次重复-ack-说明接收方后续已经收到了至少-3-个新的包-即至少三个包乱序到达-那么原来的包很可能-真的丢失了>但若出现 <code>三次重复 ACK</code> ，说明接收方后续已经收到了至少 3 个新的包（即至少三个包乱序到达），那么原来的包很可能 <code>真的丢失了</code> 。</a></li><li><a href=#发生三次重复-ack-后-tcp-怎么做>发生三次重复 ACK 后，TCP 怎么做？</a></li><li><a href=#重复ack示例>重复ACK示例</a></li></ul></li><li><a href=#linux-tcp-内核发送流程的核心机制>Linux TCP 内核发送流程的核心机制</a><ul><li><a href=#背景-tcp-发送缓冲区的本质>背景：TCP 发送缓冲区的本质</a></li><li><a href=#数据发送过程概览>数据发送过程概览</a></li><li><a href=#为什么会-没内存可用>为什么会“没内存可用”</a></li><li><a href=#缓存是怎样-释放-的>缓存是怎样“释放”的？</a></li><li><a href=#sk-stream-wait-memory-被唤醒>sk/stream/wait_memory() 被唤醒</a></li><li><a href=#继续拷贝新的数据发送>继续拷贝新的数据发送</a></li><li><a href=#总结流程图>总结流程图</a></li></ul></li><li><a href=#tcp-内核发送数据的详细流程>TCP 内核发送数据的详细流程</a><ul><li><a href=#总览-tcp-发送路径核心流程>总览：TCP 发送路径核心流程</a></li><li><a href=#tcp-sendmsg-阶段-数据进入-tcp-发送缓存>tcp_sendmsg() 阶段 —— 数据进入 TCP 发送缓存</a></li><li><a href=#tcp-push-阶段-判断是否可以发包>tcp_push() 阶段 —— 判断是否可以发包</a></li><li><a href=#tcp-cwnd-test-拥塞控制-慢启动-plus-拥塞避免>tcp_cwnd_test() — 拥塞控制（慢启动 + 拥塞避免）</a></li><li><a href=#tcp-snd-wnd-test-滑动窗口检查>tcp_snd_wnd_test() — 滑动窗口检查</a></li><li><a href=#tcp-nagle-test-nagle-算法>tcp_nagle_test() — Nagle 算法</a></li><li><a href=#tcp-window-allows-最终检查是否允许发送>tcp_window_allows() — 最终检查是否允许发送</a></li><li><a href=#tcp-transmit-skb-阶段-真正发包>tcp_transmit_skb() 阶段 —— 真正发包</a></li><li><a href=#将-tcp-报文封装上-tcp-ip-头>将 TCP 报文封装上 TCP/IP 头；</a></li><li><a href=#调用-ip-层的-ip-queue-xmit>调用 IP 层的 ip_queue_xmit()；</a></li><li><a href=#交给底层网络驱动发送>交给底层网络驱动发送。</a></li><li><a href=#整体机制之间的关系>整体机制之间的关系</a></li><li><a href=#总结流程图-整合说明>总结流程图（整合说明）</a></li><li><a href=#关键点总结>关键点总结</a></li><li><a href=#简图总结>简图总结</a></li></ul></li><li><a href=#linux-tcp-接收路径机制的理解>Linux TCP 接收路径机制的理解：</a><ul><li><a href=#阻塞与非阻塞-socket-的区别与工作机制>阻塞与非阻塞 socket 的区别与工作机制</a></li><li><a href=#应用层-recv-与网卡接收数据的关系>应用层 recv 与网卡接收数据的关系</a></li><li><a href=#recv-的-flags-参数详解>recv 的 flags 参数详解</a></li><li><a href=#多进程共享同一-socket-的并发访问>多进程共享同一 socket 的并发访问</a></li><li><a href=#tcp-low-latency-的作用>tcp /low /latency 的作用</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div><div class=post_body><h2 id=mss-作用解析>MSS 作用解析</h2><h3 id=mss-是什么>MSS 是什么？</h3><p><strong>MSS（Maximum Segment Size，最大报文段长度）</strong>
是 <strong>TCP 协议层</strong> 中一个非常关键的参数，用来表示：</p><p><strong>一个 TCP 报文段（Segment）中能携带的最大数据量（不包括 TCP/IP 头部）。</strong></p><p>先看一张逻辑关系图：</p><pre tabindex=0><code class=language-nil data-lang=nil>┌──────────────────────────────────────────────┐
│          IP 数据包（MTU，一般是 1500 字节）     │
├──────────────────────────────────────────────┤
│  IP Header (20 bytes)                        │
├──────────────────────────────────────────────┤
│  TCP Header (20 bytes)                       │
├──────────────────────────────────────────────┤
│  TCP Data (MSS)                              │
└──────────────────────────────────────────────┘
</code></pre><p>关系公式如下：</p><pre tabindex=0><code class=language-nil data-lang=nil>
MSS = MTU - IP 头长度 - TCP 头长度
</code></pre><p>通常以太网的 MTU 是 <strong>1500 字节</strong> ，
那么：</p><pre tabindex=0><code class=language-nil data-lang=nil>MSS = 1500 - 20（IP 头） - 20（TCP 头） = 1460 字节
</code></pre><h3 id=mss-的作用>MSS 的作用</h3><h4 id=1-避免-ip-分片-fragmentation>1 避免 IP 分片（Fragmentation）</h4><p>如果 TCP 报文太大，超过底层网络的 <strong>MTU</strong> ，
IP 层就必须进行 <strong>分片（Fragmentation）</strong> 。
分片容易导致：</p><h4 id=2-在-tcp-握手阶段协商>2 在 TCP 握手阶段协商</h4><p>在 <strong>三次握手（Three-way handshake）</strong> 时，
双方会在 <strong>SYN 包</strong> 里通过 TCP 选项字段交换 MSS 值。
例如：</p><table><thead><tr><th>主机</th><th>发送 SYN 时声明的 MSS</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>1460</td><td>表示 A 的最大接收段为 1460 字节</td></tr><tr><td>B</td><td>1380</td><td>表示 B 的最大接收段为 1380 字节</td></tr></tbody></table><p>建立连接后，双方会采用：</p><pre tabindex=0><code class=language-nil data-lang=nil>
实际传输 MSS =  min(1460, 1380) = 1380
</code></pre><h4 id=3-提升传输效率>3 提升传输效率</h4><h4 id=4-dot-合理设置-mss-可以>4.合理设置 MSS 可以：</h4><ul><li>减少重传代价：丢一个段时重传的数据更少。</li></ul><ul><li><p>提高吞吐率：适配链路的最优大小。</p><p>通过 MSS 限制每次发送的数据不超过 MTU 上限，可以有效避免分片问题。</p></li></ul><ul><li>避免瓶颈链路 的 MTU 不匹配问题。</li></ul><h3 id=特殊场景示例>特殊场景示例</h3><h4 id=1-dot-vpn-gre-pppoe-环境中>1. VPN / GRE / PPPoE 环境中</h4><p>这些协议会在原 IP 包外面再加封装头，导致有效 MTU 变小。
如果仍然使用默认 MSS=1460，就会触发分片或丢包。
👉 所以常见做法是使用 <strong>MSS Clamping</strong> ，
比如在路由器上设置：</p><pre tabindex=0><code class=language-nil data-lang=nil>iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN
-j TCPMSS --clamp-mss-to-pmtu
</code></pre><h4 id=2-dot-路径-mtu-发现-pmtud>2. 路径 MTU 发现（PMTUD）</h4><p>TCP 可以动态检测路径中的最小 MTU，从而调整 MSS，避免分片。</p><h2 id=rtt-是什么>RTT 是什么？</h2><p>RTT（Round Trip Time，往返时延）指的是：一个 TCP 报文从发送到收到对应 ACK 的时间。
例如：</p><ol><li>发送方发送一个数据包；</li><li>接收方收到后返回 ACK；</li><li>从发送到收到 ACK 的时间 = RTT。</li></ol><h2 id=rtt-的作用>RTT 的作用</h2><h3 id=tcp-根据-rtt-来判断超时重传-rto-rtt-系数>TCP 根据 RTT 来判断超时重传（RTO = RTT × 系数）；</h3><h3 id=拥塞控制算法以-rtt-为-一个循环单位>拥塞控制算法以 RTT 为“一个循环单位”：</h3><p>每经过一个 RTT（收到一轮 ACK），发送方就知道网络当前能承受的流量情况。</p><h2 id=ssthresh-是什么>ssthresh 是什么？</h2><p><strong>ssthresh（slow start threshold，慢启动阈值）</strong>
是一个动态的门限值，用来决定 TCP 当前处于：</p><table><thead><tr><th>状态</th><th>条件</th><th>特点</th></tr></thead><tbody><tr><td><strong>慢启动阶段</strong></td><td><code>cwnd &lt; ssthresh</code></td><td>指数增长</td></tr><tr><td><strong>拥塞避免阶段</strong></td><td><code>cwnd ≥ ssthresh</code></td><td>线性增长</td></tr></tbody></table><p>ssthresh 会随着网络拥塞动态调整：</p><h3 id=一旦网络发生拥塞-丢包或超时>一旦网络发生拥塞（丢包或超时）：</h3><pre tabindex=0><code class=language-nil data-lang=nil>ssthresh = cwnd / 2
cwnd = 1 MSS
</code></pre><p>然后重新开始慢启动。</p><h2 id=cwnd-是什么>cwnd 是什么？</h2><p><strong>cwnd（Congestion Window，拥塞窗口）</strong>
表示：发送方根据网络状况判断出的、当前允许未被确认（in-flight）的最大数据量。</p><p>发送方实际可发送的数据量取决于：</p><pre tabindex=0><code class=language-nil data-lang=nil>可发送量 =  min(cwnd, rwnd)
</code></pre><p>其中 rwnd 是接收方窗口（Receiver Window）。</p><h2 id=慢启动阶段-slow-start>慢启动阶段（Slow Start）</h2><p>当连接刚建立时，发送方并不知道网络带宽多大，因此谨慎地“试探”：</p><ol><li>初始 <code>cwnd = 1 MSS</code></li><li>每收到一个 ACK， <code>cwnd +=1 MSS</code></li><li>一个 RTT 后收到多个 ACK，于是 cwnd 翻倍
→ 呈指数增长（1, 2, 4, 8, 16 &mldr;）</li></ol><p>📈 图示：</p><pre tabindex=0><code class=language-nil data-lang=nil>时间轴:   RTT1    RTT2    RTT3    RTT4
cwnd:      1       2       4       8
</code></pre><p>增长公式（慢启动阶段）：</p><pre tabindex=0><code class=language-nil data-lang=nil>cwnd/{new} = cwnd/{old} + ACKs _received
</code></pre><p>直到 <code>cwnd ></code> ssthresh=，进入拥塞避免阶段。</p><ol><li>当网络发生丢包或超时</li></ol><p>当 TCP 检测到丢包（超时或三次重复 ACK），
认为网络拥塞，于是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>ssthresh <span style=color:#f92672>=</span> cwnd <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    cwnd <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> MSS
</span></span></code></pre></div><p>重新进入慢启动阶段。
（某些算法如 Reno、Cubic 会有更复杂的恢复策略）</p><h2 id=拥塞避免阶段-congestion-avoidance>拥塞避免阶段（Congestion Avoidance）</h2><p>当 cwnd >= ssthresh 时，TCP 认为网络可能已经接近饱和，于是改用 <strong>线性增长</strong> 的策略。</p><h3 id=原理>原理</h3><p>在慢启动阶段，每个 ACK 增加 1 MSS；
在拥塞避免阶段，每个 RTT 增加 1 MSS。</p><h3 id=过程>过程</h3><h4 id=收到一个-ack-时>收到一个 ACK 时：</h4><pre tabindex=0><code class=language-nil data-lang=nil>cwnd += 1 / cwnd
</code></pre><h4 id=一轮-rtt-大约有-cwnd-个-ack>一轮 RTT 大约有 cwnd 个 ACK，</h4><p>所以一个 RTT 结束后：</p><pre tabindex=0><code class=language-nil data-lang=nil>cwnd/new ≈ cwnd/old + 1 MSS
</code></pre><p>📈 图示：</p><pre tabindex=0><code class=language-nil data-lang=nil>时间轴:   RTT1    RTT2    RTT3    RTT4
cwnd:     10     11      12      13
</code></pre><p>即 “ <strong>每 RTT 线性增长 1 MSS</strong> ”。</p><h2 id=cwnd增长过程>cwnd增长过程</h2><p>假设：</p><ol><li>初始 cwnd = 1 MSS；</li><li>ssthresh = 8 MSS；</li></ol><p>增长过程如下：</p><table><thead><tr><th>阶段</th><th>RTT 次数</th><th>cwnd 值</th><th>增长方式</th></tr></thead><tbody><tr><td>慢启动</td><td>1</td><td>1</td><td>初始</td></tr><tr><td>慢启动</td><td>2</td><td>2</td><td>翻倍</td></tr><tr><td>慢启动</td><td>3</td><td>4</td><td>翻倍</td></tr><tr><td>慢启动</td><td>4</td><td>8</td><td>达到阈值</td></tr><tr><td>拥塞避免</td><td>5</td><td>9</td><td>每 RTT +1</td></tr><tr><td>拥塞避免</td><td>6</td><td>10</td><td>每 RTT +1</td></tr><tr><td>拥塞避免</td><td>7</td><td>11</td><td>每 RTT +1</td></tr></tbody></table><p>📈结果：</p><ul><li>慢启动阶段增长迅速（指数级）</li><li>拥塞避免阶段增长平稳（线性）</li><li>cwnd变化图</li></ul><pre tabindex=0><code class=language-nil data-lang=nil>cwnd
│
│                /&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39; (线性增长)
│               /
│              /
│             /
│            /
│           /
│          /
│         /
│        /
│       /
│      /
│     /
│    /
│   /
│  /
│ /       ← 指数增长（慢启动）
│/
└───────────────────────────────→ 时间
↑
ssthresh点
</code></pre><h2 id=rtt-cwnd-ssthresh-总结对比>RTT,cwnd,ssthresh 总结对比</h2><table><thead><tr><th>概念</th><th>全称</th><th>控制目标</th><th>增长模式</th><th>调整时机</th></tr></thead><tbody><tr><td><strong>RTT</strong></td><td>Round Trip Time</td><td>衡量网络时延</td><td>—</td><td>动态测量</td></tr><tr><td><strong>cwnd</strong></td><td>Congestion Window</td><td>控制发送方流量</td><td>慢启动：指数</td><td></td></tr></tbody></table><p>拥塞避免：线性 | 每收到 ACK |</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>ssthresh</strong></td><td>Slow Start Threshold</td><td>决定阶段切换</td><td>—</td><td>拥塞时减半</td></tr></tbody></table><h2 id=什么是-ack-与-重复的-ack>什么是 ACK 与“重复的 ACK”</h2><p>在 TCP 中：</p><h3 id=ack-确认报文-用来告诉发送方-我已经收到了某个序号之前的所有字节数据>ACK（确认报文） 用来告诉发送方：“我已经收到了某个序号之前的所有字节数据。”</h3><h3 id=ack-的值是下一个期望收到的字节序号-即-cumulative-ack-累积确认>ACK 的值是下一个期望收到的字节序号（即 cumulative ACK，累积确认）。</h3><p>例如：</p><pre tabindex=0><code class=language-nil data-lang=nil>发送方发送的数据：
序号 1~1000, 1001~2000, 2001~3000, 3001~4000
</code></pre><p>接收方按序收到后，会依次发：</p><pre tabindex=0><code class=language-nil data-lang=nil>ACK=1001 → ACK=2001 → ACK=3001 → ACK=4001
</code></pre><h3 id=什么是-三次重复-ack>什么是“三次重复 ACK”</h3><p><strong>重复 ACK</strong> ：接收方在收到 <strong>乱序数据</strong> 时，会 <strong>重复发送相同的 ACK 值</strong> （即上一个已确认的字节号）。
这说明：</p><p>“我还在等你丢失的那个包，后面的我都收到了，但我没法交给上层。”</p><p>举个例子：</p><table><thead><tr><th>发送顺序</th><th>分组序号</th><th>是否丢失</th><th>接收方行为</th></tr></thead><tbody><tr><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr><tr><td>#1</td><td>Seq=1~1000</td><td>✅</td><td>发 ACK=1001</td></tr><tr><td>#2</td><td>Seq=1001~2000</td><td>❌ 丢失</td><td>无法确认</td></tr><tr><td>#3</td><td>Seq=2001~3000</td><td>✅ 收到，但发现 1001~2000 缺失</td><td>发 <strong>ACK=1001（重复ACK #1）</strong></td></tr><tr><td>#4</td><td>Seq=3001~4000</td><td>✅ 收到，但缺失仍在</td><td>发 <strong>ACK=1001（重复ACK #2）</strong></td></tr><tr><td>#5</td><td>Seq=4001~5000</td><td>✅ 收到，但缺失仍在</td><td>发 <strong>ACK=1001（重复ACK #3）</strong></td></tr></tbody></table><p>当发送方连续收到 <strong>3 个相同的 ACK（即“三次重复 ACK”）</strong> 时，
就说明：</p><p>某个包 <strong>真的丢了</strong> （而不是仅仅乱序）。</p><h3 id=为什么-三次-是阈值>为什么“三次”是阈值？</h3><p>因为网络中 <strong>乱序现象</strong> 是可能发生的：</p><h3 id=如果只是一个包被延迟-可能导致一两次重复-ack>如果只是一个包被延迟，可能导致一两次重复 ACK；</h3><h3 id=但若出现-三次重复-ack-说明接收方后续已经收到了至少-3-个新的包-即至少三个包乱序到达-那么原来的包很可能-真的丢失了>但若出现 <code>三次重复 ACK</code> ，说明接收方后续已经收到了至少 3 个新的包（即至少三个包乱序到达），那么原来的包很可能 <code>真的丢失了</code> 。</h3><p>所以 TCP 规定：</p><p>收到三次重复 ACK 时，不再等待超时，而是立刻重传丢失的分段。</p><p>这就是 <strong>快速重传（Fast Retransmit）</strong> 。</p><h3 id=发生三次重复-ack-后-tcp-怎么做>发生三次重复 ACK 后，TCP 怎么做？</h3><ol><li><strong>立即重传</strong> 丢失的数据段；</li><li><strong>进入快速恢复（Fast Recovery）阶段</strong> ；</li><li>调整控制变量：<ul><li><code>ssthresh = cwnd / 2</code> （阈值减半）</li><li><code>cwnd = ssthresh + 3 MSS</code> （保留一定的“快速恢复”空间）</li></ul></li></ol><h4 id=在快速恢复阶段>在快速恢复阶段：</h4><ul><li><p>每收到一个重复 ACK，就意味着又有一个包离开网络（被确认），所以：</p><pre tabindex=0><code class=language-nil data-lang=nil>cwnd += MSS
</code></pre><p>（允许继续发送新的数据）</p></li></ul><ul><li><p>当收到新的 ACK（不再是重复 ACK）时：</p><pre tabindex=0><code class=language-nil data-lang=nil>cwnd = ssthresh
</code></pre><p>（退出快速恢复，进入拥塞避免）</p></li></ul><ul><li>总结<table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td><strong>RTT</strong></td><td>往返时延（一个包从发送到收到 ACK 的时间）</td></tr><tr><td><strong>cwnd</strong></td><td>拥塞窗口，限制网络中未确认数据量</td></tr><tr><td><strong>ssthresh</strong></td><td>慢启动阈值，控制慢启动到拥塞避免的切换点</td></tr><tr><td><strong>重复 ACK</strong></td><td>表示有乱序或丢包</td></tr><tr><td><strong>三次重复 ACK</strong></td><td>判断丢包，触发快速重传</td></tr><tr><td><strong>快速重传 + 快速恢复</strong></td><td>避免超时等待，提升性能，减少重传延迟</td></tr></tbody></table></li></ul><ul><li><p>示意图</p><pre tabindex=0><code class=language-nil data-lang=nil>cwnd
↑
│
│                ┌───────────── 快速恢复
│               /
│              /
│     ┌───────┘
│    /
│   /
└──┘
↑  ↑
慢启动  拥塞避免
</code></pre></li></ul><h4 id=在拥塞避免阶段-如果发生-三次重复-ack-会>在拥塞避免阶段，如果发生 <code>三次重复 ACK</code> ，会：</h4><ol><li>重传丢包；</li><li>减小 cwnd；</li><li>进入快速恢复；</li><li>等新的 ACK 确认后恢复正常增长。</li></ol><h3 id=重复ack示例>重复ACK示例</h3><ol><li>每个数据段大小 = 1 MSS</li><li>cwnd 初始 = 1 MSS</li><li>ssthresh 初始 = 8 MSS</li><li>网络发生丢包：发送第 6 个包时丢失</li></ol><p>时序图：</p><pre tabindex=0><code class=language-nil data-lang=nil>时间 →
发送方 cwnd 变化过程（每个 RTT ）
────────────────────────────────────────────

阶段1：慢启动（Slow Start）
────────────────────────────────────────────
RTT 1: cwnd = 1 MSS → 发送 #1
RTT 2: 收到 ACK1 → cwnd = 2 MSS → 发送 #2, #3
RTT 3: 收到 ACK3 → cwnd = 4 MSS → 发送 #4, #5, #6, #7
↑
└── (#6 丢失)

────────────────────────────────────────────
阶段2：重复 ACK 出现（Fast Retransmit 触发前）
────────────────────────────────────────────
接收方收到：#4, #5, #7 但缺 #6
连续发送：
ACK = 6001
ACK = 6001 (dup #1)
ACK = 6001 (dup #2)
ACK = 6001 (dup #3)

发送方收到“三次重复 ACK” → 判断丢包！

────────────────────────────────────────────
阶段3：快速重传（Fast Retransmit）
────────────────────────────────────────────
操作：
ssthresh = cwnd / 2 = 4 / 2 = 2 MSS
cwnd = ssthresh + 3*MSS = 2 + 3 = 5 MSS
立即重传 #6

────────────────────────────────────────────
阶段4：快速恢复（Fast Recovery）
────────────────────────────────────────────
此时，发送方认为有几个包已经离开网络，
每收到一个额外的重复ACK，说明又有一个包被确认：

重复ACK #4 → cwnd += 1 MSS (6 MSS)
重复ACK #5 → cwnd += 1 MSS (7 MSS)
...

当收到新的 ACK（确认到 #7 之后的数据）：
→ 意味着丢失的包已被成功接收，
→ 退出快速恢复阶段。

退出时：
cwnd = ssthresh = 2 MSS

────────────────────────────────────────────
阶段5：拥塞避免（Congestion Avoidance）
────────────────────────────────────────────
之后每 RTT 线性增长：
cwnd = cwnd + 1 MSS 每 RTT
</code></pre><h2 id=linux-tcp-内核发送流程的核心机制>Linux TCP 内核发送流程的核心机制</h2><p>内核中为这个 TCP 连接分配的内核缓存是有限的（/proc/sys/net/core/wmem/default）。当没有多余的内核态缓存来复制用户态的待发送数据时，就需要调用一个方法sk/stream/wait/memory来等待滑动窗口移动，释放出一些缓存出来（收到 ACK 后，不需要再缓存原来已经发送出的报文，因为既然已经确认对方收到，就不需要定时重发，自然就释放缓存了）</p><p>为什么说需要调用一个方法sk/stream/wait_memory来等待滑动窗口移动，具体是怎样释放出一些缓存出来的？</p><h3 id=背景-tcp-发送缓冲区的本质>背景：TCP 发送缓冲区的本质</h3><p>在 Linux 内核中，每个 TCP 套接字（=struct sock=）都有两个关键缓冲区：</p><table><thead><tr><th>缓冲区</th><th>内核字段</th><th>作用</th></tr></thead><tbody><tr><td>发送缓冲区</td><td><code>sk/write/queue</code> / <code>sk/wmem/queued</code></td><td>存放还未被确认（ACK）的数据</td></tr><tr><td>接收缓冲区</td><td><code>sk/receive/queue</code> / <code>sk/rmem/queued</code></td><td>存放收到但未被应用读取的数据</td></tr></tbody></table><h3 id=数据发送过程概览>数据发送过程概览</h3><p>当用户程序调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>send</span>(sock, buf, len, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>时，大致流程如下：</p><ul><li><strong>用户态 → 内核态</strong> ：
数据从用户空间拷贝到内核的 TCP 发送缓存中。</li><li><strong>TCP 层封包</strong> ：
TCP 将数据分段（按 MSS）并发送出去。</li><li><strong>等待 ACK</strong> ：
数据未被确认前仍保存在内核缓冲区（用于超时重传）。</li><li><strong>收到 ACK</strong> ：
对方确认收到某段数据，TCP 内核即可释放对应缓存。</li></ul><h3 id=为什么会-没内存可用>为什么会“没内存可用”</h3><p>当 <strong>发送速率高</strong> 、但 <strong>对方接收慢</strong> 或 <strong>网络延迟大</strong> 时：</p><h4 id=内核缓冲区中的数据不断积压>内核缓冲区中的数据不断积压；</h4><h4 id=sk-wmem-queued-已缓存但未-ack-的数据量-逐渐逼近上限><code>sk/wmem/queued</code> （已缓存但未 ACK 的数据量）逐渐逼近上限；</h4><h4 id=上限由-proc-sys-net-core-wmem-default-和-tcp-自动调节机制-tcp-wmem-决定>上限由 /proc/sys/net/core/wmem/default 和 TCP 自动调节机制（tcp/wmem）决定。</h4><p>此时， <code>send()</code> 无法再拷贝更多数据到内核缓冲区，
内核必须“停下来”等待可用内存。
这就是调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>sk<span style=color:#f92672>/</span>stream<span style=color:#f92672>/</span><span style=color:#a6e22e>wait_memory</span>(sk);
</span></span></code></pre></div><p>的时机。</p><h4 id=sk-stream-wait-memory-在干什么>sk/stream/wait_memory() 在干什么？</h4><p>这个函数的核心逻辑是：</p><p>当发送缓冲区已满，TCP 发送函数必须挂起（sleep），直到内核有可用的发送内存。</p><p>伪代码简化如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#960050;background-color:#1e0010>发送缓存不足</span>) {
</span></span><span style=display:flex><span>    sk<span style=color:#f92672>/</span>stream<span style=color:#f92672>/</span><span style=color:#a6e22e>wait_memory</span>(sk);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>sk/stream/wait_memory()</code> 做了三件事：</p><ul><li><strong>设置等待条件</strong>
它会让当前进程进入 *等待队列*（ <code>sk->sk/write/queue</code> 对应的 wait queue），
等待条件是：*有内存释放 或 窗口可用 或 超时/信号到达*。</li><li><strong>睡眠（schedule）</strong>
当前进程阻塞，直到条件满足。</li><li><strong>被唤醒</strong>
当 ACK 到达或内核缓冲区释放空间后，唤醒等待进程，继续发送。</li></ul><h3 id=缓存是怎样-释放-的>缓存是怎样“释放”的？</h3><p>释放的时机主要是：</p><h4 id=1-dot-收到-ack-确认数据>1. 收到 ACK 确认数据</h4><p>每个被确认的数据段在 <code>tcp_ack()</code> 中被处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>tcp<span style=color:#f92672>/</span>clean<span style=color:#f92672>/</span>rtx<span style=color:#f92672>/</span><span style=color:#a6e22e>queue</span>(sk, ack<span style=color:#f92672>/</span>seq);
</span></span></code></pre></div><p>这个函数会：</p><ul><li>从重传队列中删除已确认的数据包；</li><li>调整 =sk/wmem/queued=；</li><li>调用 <code>sk/stream/write_space(sk)</code> 释放内存并唤醒等待队列。</li></ul><h4 id=2-dot-sk-stream-write-space-唤醒发送者>2. sk/stream/write_space() 唤醒发送者</h4><p>当可用缓存恢复时，它会调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (waitqueue<span style=color:#f92672>/</span><span style=color:#a6e22e>active</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk<span style=color:#f92672>/</span>write_queue))
</span></span><span style=display:flex><span>    wake<span style=color:#f92672>/</span><span style=color:#a6e22e>up</span>(<span style=color:#f92672>&amp;</span>sk<span style=color:#f92672>-&gt;</span>sk<span style=color:#f92672>/</span>write_queue);
</span></span></code></pre></div><p>唤醒所有在 <code>sk/stream/wait_memory()</code> 里睡眠的进程。
于是 send() 可以继续写。</p><h4 id=3-dot-滑动窗口与内核缓存的关系>3. 滑动窗口与内核缓存的关系</h4><hr><table><thead><tr><th>概念</th><th>所在层</th><th>控制对象</th><th>作用</th></tr></thead><tbody><tr><td><strong>滑动窗口</strong></td><td>TCP 协议层</td><td>数据确认与流量控制</td><td>告诉发送方还能发送多少字节</td></tr><tr><td><strong>内核缓存</strong></td><td>操作系统内核</td><td>内存使用限制</td><td>决定内核能缓存多少待发送数据</td></tr></tbody></table><p>两者的结合点是：只有当滑动窗口前进（ACK 到达）时，内核才可以释放缓存空间。
因此：</p><ul><li>ACK → 滑动窗口右移；</li><li>TCP 知道哪些数据可以丢弃；</li><li>释放相应的 <code>sk_buff</code> ；</li><li>可用缓存上升；</li></ul><h3 id=sk-stream-wait-memory-被唤醒>sk/stream/wait_memory() 被唤醒</h3><h3 id=继续拷贝新的数据发送>继续拷贝新的数据发送</h3><h3 id=总结流程图>总结流程图</h3><pre tabindex=0><code class=language-nil data-lang=nil>用户调用 send()
│
├─ 拷贝数据到 TCP 发送缓冲区
│
├─ 缓冲区足够 → 正常返回
│
└─ 缓冲区不足 → 调用 sk/stream/wait_memory()
│
├─ 进程进入等待队列 (sleep)
│
├─ 收到 ACK → tcp/clean/rtx_queue() → 释放缓存
│
└─ sk/stream/write_space() → 唤醒等待进程
↓
send() 继续执行
</code></pre><h2 id=tcp-内核发送数据的详细流程>TCP 内核发送数据的详细流程</h2><h3 id=总览-tcp-发送路径核心流程>总览：TCP 发送路径核心流程</h3><p>发送逻辑可以概括为以下阶段：</p><pre tabindex=0><code class=language-nil data-lang=nil>用户态 send()
│
▼
tcp_sendmsg()        ← 负责拷贝数据到内核发送缓存
│
│-- sk/stream/wait_memory() 等待可用内存
│-- 数据封装成 sk_buff (skb)
▼
tcp_push()           ← 判断是否可以立即发送
│
│-- tcp/cwnd/test()      拥塞控制检查
│-- tcp/snd/wnd_test()   滑动窗口检查
│-- tcp/nagle/test()     Nagle 算法判断
│-- tcp/window/allows()  综合检查发送条件
▼
tcp/transmit/skb()   ← 通过 IP 层发出真正的报文段
</code></pre><h3 id=tcp-sendmsg-阶段-数据进入-tcp-发送缓存>tcp_sendmsg() 阶段 —— 数据进入 TCP 发送缓存</h3><h4 id=内核空间分配发送缓存>内核空间分配发送缓存</h4><ul><li>如果内核缓存不足，会调用：</li></ul><pre tabindex=0><code class=language-nil data-lang=nil>sk/stream/wait_memory(sk);
</code></pre><ul><li>当前发送进程会 <strong>睡眠等待</strong> ；</li><li>直到收到 ACK 后释放缓存、或内核有新的空间。</li></ul><p>这里与滑动窗口相关：
收到 ACK → 窗口右移 → 可发送数据量变多 → 内核释放缓存。</p><h4 id=拷贝数据进入-sk-write-queue>拷贝数据进入 <code>sk/write/queue</code></h4><ul><li>每个发送的数据段会被封装为一个 <code>skb</code> ；</li><li>放入 TCP 的发送队列等待发送。</li></ul><h3 id=tcp-push-阶段-判断是否可以发包>tcp_push() 阶段 —— 判断是否可以发包</h3><p>这个阶段是 TCP 发送逻辑的核心控制环节。
它包含了拥塞控制、流量控制和发送优化机制。</p><h3 id=tcp-cwnd-test-拥塞控制-慢启动-plus-拥塞避免>tcp_cwnd_test() — 拥塞控制（慢启动 + 拥塞避免）</h3><p>这是拥塞窗口（ <strong>Congestion Window, cwnd</strong> ）的检查点。</p><h4 id=cwnd-拥塞窗口-表示当前发送方根据网络状态允许发送的最大未确认数据量>cwnd（拥塞窗口） 表示当前发送方根据网络状态允许发送的最大未确认数据量；</h4><h4 id=与接收方汇报的-rwnd-接收窗口-共同限制发送速率>与接收方汇报的 rwnd（接收窗口） 共同限制发送速率。</h4><p>计算公式为：</p><pre tabindex=0><code class=language-nil data-lang=nil>可发送量 =  min(cwnd, rwnd) - 已发送未确认字节数
</code></pre><h4 id=慢启动阶段-slow-start>慢启动阶段（Slow Start） ：</h4><ul><li>cwnd 初始为 1 个 MSS；</li><li>每收到一个 ACK，就增加 1 个 MSS；</li><li>呈指数增长，直到达到阈值 ssthresh。</li></ul><h4 id=拥塞避免阶段-congestion-avoidance>拥塞避免阶段（Congestion Avoidance） ：</h4><ul><li>cwnd 超过 ssthresh 后，每 RTT 线性增长。</li></ul><p>当检测到丢包（超时或三次重复 ACK）时：</p><ul><li>TCP 进入 快速重传 / 拥塞恢复</li><li>cwnd 被减半，ssthresh 重新设定。</li></ul><p>tcp/cwnd/test() 是发送前的第一道“交通信号灯”，
确保当前发送量不超过网络允许的带宽上限。</p><h3 id=tcp-snd-wnd-test-滑动窗口检查>tcp_snd_wnd_test() — 滑动窗口检查</h3><p>滑动窗口由接收端通过 ACK 报文的 <strong>window 字段</strong> 告诉发送端。
它反映了接收方可用缓冲区大小。</p><p>TCP 发送方必须保证：</p><pre tabindex=0><code class=language-nil data-lang=nil>未确认数据 ≤ 接收方窗口
</code></pre><p><code>tcp/snd/wnd_test()</code> 就是检查：</p><h4 id=待发送报文的-序号-是否超出了接收窗口>待发送报文的 序号 是否超出了接收窗口；</h4><h4 id=若超出-则不能发送-等待-ack-更新窗口>若超出，则不能发送，等待 ACK 更新窗口。</h4><ol><li><code>tcp/cwnd/test</code> 控制 <strong>网络层的带宽拥塞</strong> ，</li><li><code>tcp/snd/wnd_test</code> 控制 <strong>对端的接收能力</strong> 。</li></ol><p>两者共同形成发送速率的“上限闸门”。</p><h3 id=tcp-nagle-test-nagle-算法>tcp_nagle_test() — Nagle 算法</h3><p><strong>Nagle 算法</strong> 的目标是：减少发送过多的小包，提高带宽利用率。
算法规则：</p><ul><li>如果已经有一个未确认的数据包（in-flight），并且当前要发送的数据长度小于 MSS，则 <strong>延迟发送</strong> ；</li><li>直到收到 ACK 或者 数据积累到 MSS 大小。</li></ul><p>这样可以避免在交互式应用（如 Telnet）中频繁发送很小的 TCP 包。=tcp/nagle/test()= 控制小包的发送时机，减少网络负载。
（可以通过 <code>TCP_NODELAY</code> socket 选项关闭该算法）</p><h3 id=tcp-window-allows-最终检查是否允许发送>tcp_window_allows() — 最终检查是否允许发送</h3><p>该函数结合前面所有条件：</p><ul><li>拥塞窗口 <code>cwnd</code></li><li>接收窗口 <code>rwnd</code></li><li>Nagle 状态</li><li>实际待发送字节数</li></ul><p>计算出是否满足：</p><pre tabindex=0><code class=language-nil data-lang=nil>发送数据长度 ≤  min(cwnd, rwnd)
</code></pre><p>满足则允许发包，否则继续等待窗口或 ACK。</p><h3 id=tcp-transmit-skb-阶段-真正发包>tcp_transmit_skb() 阶段 —— 真正发包</h3><p>当所有条件满足后，TCP 调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>tcp<span style=color:#f92672>/</span>transmit<span style=color:#f92672>/</span><span style=color:#a6e22e>skb</span>(sk, skb);
</span></span></code></pre></div><h3 id=将-tcp-报文封装上-tcp-ip-头>将 TCP 报文封装上 TCP/IP 头；</h3><h3 id=调用-ip-层的-ip-queue-xmit>调用 IP 层的 ip_queue_xmit()；</h3><h3 id=交给底层网络驱动发送>交给底层网络驱动发送。</h3><p>若开启了重传定时器，会将此 skb 放入重传队列，等待 ACK。</p><h3 id=整体机制之间的关系>整体机制之间的关系</h3><table><thead><tr><th>控制机制</th><th>层次</th><th>控制目标</th><th>对应函数</th></tr></thead><tbody><tr><td><strong>慢启动 / 拥塞控制</strong></td><td>发送方内核</td><td>防止网络过载</td><td><code>tcp/cwnd/test</code></td></tr><tr><td><strong>滑动窗口</strong></td><td>接收端反馈</td><td>防止接收方缓存溢出</td><td><code>tcp/snd/wnd_test</code></td></tr><tr><td><strong>Nagle 算法</strong></td><td>应用层优化</td><td>减少小包，提高带宽利用率</td><td><code>tcp/nagle/test</code></td></tr><tr><td><strong>内核缓存 / 内存等待</strong></td><td>内核内存管理</td><td>避免内核 OOM 或 send() 无限写</td><td><code>sk/stream/wait_memory</code></td></tr></tbody></table><p>这些机制共同实现：
TCP 的三大特性： <strong>可靠传输、流量控制、拥塞控制</strong> 。</p><h3 id=总结流程图-整合说明>总结流程图（整合说明）</h3><pre tabindex=0><code class=language-nil data-lang=nil>用户态 send()
  │
  ▼
tcp_sendmsg()
  ├─ sk_stream_wait_memory() 等待内核缓存可用（受滑动窗口影响）
  ├─ 将数据拷贝到发送缓存 skb 队列
  ▼
tcp_push()
  ├─ tcp_cwnd_test() 拥塞控制：是否超过 cwnd
  ├─ tcp_snd_wnd_test() 流量控制：是否超过接收窗口 rwnd
  ├─ tcp_nagle_test() Nagle 算法：是否应立即发送
  ├─ tcp_window_allows() 综合检查
  ▼
tcp_transmit_skb()
  └─ 交给 IP 层发送数据包
</code></pre><h3 id=关键点总结>关键点总结</h3><table><thead><tr><th>阶段</th><th>触发条件</th><th>cwnd 变化</th><th>ssthresh 变化</th><th>说明</th></tr></thead><tbody><tr><td><strong>慢启动</strong></td><td>初始化或恢复后</td><td>每 RTT 翻倍</td><td>不变</td><td>快速探测带宽</td></tr><tr><td><strong>拥塞避免</strong></td><td>cwnd ≥ ssthresh</td><td>每 RTT +1 MSS</td><td>不变</td><td>线性增长，稳态传输</td></tr><tr><td><strong>三次重复 ACK</strong></td><td>检测到丢包</td><td>cwnd → ssthresh + 3 *MSS</td><td>ssthresh = cwnd/2</td><td>启动快速重传</td></tr><tr><td><strong>快速恢复</strong></td><td>收到重复 ACK</td><td>cwnd += 1 MSS/dup ACK</td><td>不变</td><td>模拟确认包流出</td></tr><tr><td><strong>退出快速恢复</strong></td><td>收到新 ACK</td><td>cwnd = ssthresh</td><td>保持</td><td>回到拥塞避免</td></tr></tbody></table><h3 id=简图总结>简图总结</h3><pre tabindex=0><code class=language-nil data-lang=nil>cwnd
│
│               ┌─── 线性增长（拥塞避免）
│             ┌─┘
│        ┌────┘
│   ┌────┘
│  / 慢启动（指数增长）
│ /
└──────────────────────→ 时间
↑       ↑
│       └── 三次重复ACK触发快速重传
└── 拥塞窗口达到 ssthresh
</code></pre><h2 id=linux-tcp-接收路径机制的理解>Linux TCP 接收路径机制的理解：</h2><p>1、应用程序调用 read、recv 等方法时，socket 套接字可以设置为阻塞或者非阻塞，这两种方式是如何工作的？</p><p>2、若 socket 为默认的阻塞套接字，此时 recv 方法传入的 len 参数，是表示必须超时（SO/RCVTIMEO）或者接收到 len 长度的消息，recv 方法才会返回吗？而且，socket上可以设置一个属性叫做SO/RCVLOWAT，它会与 len 产生什么样的交集，又是决定 recv 等接收方法什么时候返回？</p><p>3、应用程序开始收取 TCP 消息，与程序所在的机器网卡上接收到网络里发来的 TCP 消息，这是两个独立的流程。它们之间是如何互相影响的？例如，应用程序正在收取消息时，内核通过网卡又在这条 TCP 连接上收到消息时，究竟是如何处理的？若应用程序没有调用 read 或者 recv 时，内核收到 TCP 连接上的消息后又是怎样处理的？</p><p>4、recv 这样的接收方法还可以传入各种 flags，例如MSG/WAITALL、MSG/PEEK、MSG_TRUNK等等。它们是如何工作的？</p><p>5、1 个 socket 套接字可能被多个进程在使用，出现并发访问时，内核是怎么处理这种状况的？</p><p>6、linux 的 sysctl 系统参数中，有类似tcp/low/latency这样的开关，默认为 0 或者配置为 1 时是如何影响 TCP 消息处理流程的？</p><h3 id=阻塞与非阻塞-socket-的区别与工作机制>阻塞与非阻塞 socket 的区别与工作机制</h3><h4 id=阻塞-默认模式>阻塞（默认模式）</h4><p>当应用程序调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>recv</span>(sockfd, buf, len, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>时，如果 <strong>内核接收缓冲区中没有数据</strong> ：</p><ul><li>系统调用会 进入睡眠（blocked），直到收到网络数据放入缓冲区；</li><li>或者超时（SO_RCVTIMEO）；</li><li>或者连接被关闭，才会被唤醒、返回结果。</li></ul><p>即：“应用在等数据，内核在睡眠，等待中断驱动把数据填到接收缓冲区。”</p><h4 id=非阻塞模式-o-nonblock>非阻塞模式（=O_NONBLOCK=）</h4><p>如果缓冲区中没有数据：</p><ul><li>recv() 立即返回 -1；</li><li>并设置 errno=EAGAIN 或 EWOULDBLOCK
所以非阻塞 socket 一般要与 <strong>epoll/poll/select</strong> 等 I/O 多路复用机制配合使用。</li></ul><ul><li><p>recv 的 len、SO_RCVTIMEO 与 SO_RCVLOWAT 的关系</p><ul><li><p>len 参数</p><p><code>len</code> 表示应用程序想要读取的最大字节数；并不是说必须读够 len 才返回。
默认行为： <strong>只要缓冲区里有 ≥1 字节可读，就立即返回</strong> 。</p></li></ul><ul><li><p>SO_RCVTIMEO</p><p>这是 <strong>阻塞超时参数</strong> （单位：秒+微秒）。</p><ul><li>recv 等待数据时超时； 就返回 -1，并设置 <code>errno = EAGAIN</code>, 不会影响数据量，只影响 <strong>等待时间</strong> 。</li></ul></li></ul><ul><li><p>SO_RCVLOWAT（“低水位”）</p><p>这是“ <strong>返回所需的最小可用字节数</strong> ”阈值。</p><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> lowat <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>setsockopt</span>(sockfd, SOL<span style=color:#f92672>/</span>SOCKET, SO<span style=color:#f92672>/</span>RCVLOWAT, <span style=color:#f92672>&amp;</span>lowat, <span style=color:#66d9ef>sizeof</span>(lowat));
</span></span><span style=display:flex><span><span style=color:#a6e22e>recv</span>(sockfd, buf, <span style=color:#ae81ff>1000</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>→ 当接收缓冲区的数据 &lt; 100 字节时， <code>recv</code> 不会返回（阻塞等待）。</p><p>⚠️ 但如果连接关闭（FIN 到达），则立即返回现有数据。</p><p>💡所以：</p><pre tabindex=0><code class=language-nil data-lang=nil>recv() 的返回条件
(数据 &gt;= min(len, SO_RCVLOWAT)) || (连接关闭) || (超时/错误)
</code></pre></li></ul></li></ul><h3 id=应用层-recv-与网卡接收数据的关系>应用层 recv 与网卡接收数据的关系</h3><h4 id=两条独立路径>两条独立路径：</h4><ol><li><strong>网卡到内核（硬中断 / NAPI）</strong><ul><li>网卡收到 TCP 报文；</li><li>触发中断；</li><li>驱动程序将数据 DMA 到内存；</li><li>内核协议栈（tcp /rcv /established）解析报文；</li><li>把数据放入 socket 的 <code>sk/receive/queue</code> 。</li></ul></li><li><strong>应用层读取（read/recv）</strong><ul><li>从 <code>sk/receive/queue</code> 取数据；</li><li>复制到用户空间；</li><li>更新窗口（ACK 告诉对方还能发多少）。</li></ul></li></ol><h4 id=应用和网卡的交互>应用和网卡的交互</h4><ul><li>两者异步进行：网卡可以不停收包，即使应用没读。</li><li>如果应用一直不读，内核 recv buffer 会被填满；</li><li>TCP 会通告对端窗口为 0；</li><li>对端暂停发送；</li><li>出现 零窗口（Zero Window） 状态；</li><li>当应用再读时，窗口更新，对方才继续发。</li></ul><h3 id=recv-的-flags-参数详解>recv 的 flags 参数详解</h3><table><thead><tr><th>flag</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>MSG_WAITALL</code></td><td>阻塞直到接收满 <code>len</code> 字节或出错</td><td>流式数据如文件下载</td></tr><tr><td><code>MSG_PEEK</code></td><td>仅窥视数据，不移除缓冲区</td><td>协议头判断或探测</td></tr><tr><td><code>MSG_TRUNC</code></td><td>对 UDP 表示返回实际报文长度</td><td>获取被截断包真实长度</td></tr><tr><td><code>MSG_DONTWAIT</code></td><td>临时非阻塞调用</td><td>临时跳过阻塞</td></tr><tr><td><code>MSG_ERRQUEUE</code></td><td>读取错误队列（如 ICMP 错误）</td><td>原始 socket 或诊断</td></tr><tr><td><code>MSG_NOSIGNAL</code></td><td>避免发送 SIGPIPE 信号</td><td>写入已关闭 socket</td></tr></tbody></table><h3 id=多进程共享同一-socket-的并发访问>多进程共享同一 socket 的并发访问</h3><h4 id=fork-后继承-socket-父子进程共享-时>fork() 后继承 socket（父子进程共享）时：</h4><ul><li>套接字结构（struct sock）在内核中只有一份，引用计数增加；</li></ul><ul><li>所有进程共用同一个 TCP 连接；</li></ul><h4 id=多个进程同时-recv-时>多个进程同时 <code>recv</code> 时：</h4><ul><li>内核通过锁（ <code>sk_lock</code> ）保护；</li></ul><ul><li>数据被“竞争性”取走；</li></ul><ul><li><p>谁先读谁拿到，另一个读时就少了。</p><p>⚠️ 因此：
多进程并发 recv 同一个 TCP socket 不安全！
通常只在父进程 <code>fork</code> 后， <strong>让子进程各自 accept 新连接</strong> 才安全。</p></li></ul><h3 id=tcp-low-latency-的作用>tcp /low /latency 的作用</h3><p>Linux 内核参数：</p><pre tabindex=0><code class=language-nil data-lang=nil>/proc/sys/net/ipv4/tcp/low/latency
</code></pre><p>默认： <code>0</code> （关闭）</p><h4 id=启用后-设为-1>启用后（设为 1）：</h4><ul><li>优化算法选择偏向*低延迟（Latency）；</li><li>牺牲部分*带宽效率（Throughput）；</li><li>关闭一些延迟确认（Delayed ACK）；</li><li>让 TCP 在未满 MSS 也尽快发出数据；</li><li>对交互式流（如 SSH、RPC）更友好。</li></ul><h4 id=禁用后-设为-0>禁用后（设为 0）：</h4><ul><li>内核偏向高吞吐；</li><li>合并更多包发送（Nagle、Delayed ACK）；</li><li>更适合批量传输（如文件传输、HTTP）。</li></ul><h3 id=总结>总结</h3><table><thead><tr><th>概念</th><th>作用</th><th>内核机制</th></tr></thead><tbody><tr><td>阻塞 socket</td><td>没数据则睡眠</td><td>等待 sk /receive /queue 非空</td></tr><tr><td>非阻塞 socket</td><td>立即返回</td><td>errno=EAGAIN</td></tr><tr><td>SO /RCVLOWAT</td><td>阻塞最小字节阈值</td><td>sk /rcvlowat</td></tr><tr><td>SO /RCVTIMEO</td><td>接收超时</td><td>sock /wait /for /data()</td></tr><tr><td>recv flags</td><td>精细控制行为</td><td>flags 影响内核逻辑</td></tr><tr><td>多进程共享 socket</td><td>内核锁 + 数据竞争</td><td>struct sock 共享</td></tr><tr><td>tcp /low /latency</td><td>优先低延迟</td><td>调整 TCP 算法行为</td></tr></tbody></table></div><div class=post_comments></div></article><aside class=sidebar><section class=sidebar_inner><br><h2 class=mt-4>Recent Posts</h2><ul class=flex-column><li><a href=https://songronghu.github.io/posts/2025-12-03/ class=nav-link title="TCP 发送数据 核心流程">TCP 发送数据 核心流程</a></li><li><a href=https://songronghu.github.io/posts/deploy_personal_blog/ class=nav-link title=使用hugo搭建博客>使用hugo搭建博客</a></li><li><a href=https://songronghu.github.io/posts/my-first-blog/ class=nav-link title=我的第一篇博客>我的第一篇博客</a></li></ul><div><h2 class="mt-4 taxonomy" id=categories-section>Categories</h2><nav class=tags_nav><a href=https://songronghu.github.io/categories/%E6%8A%80%E6%9C%AF/ class="post_tag button button_translucent" title=技术>技术
<span class=button_tally>2</span></a></nav></div><div><h2 class="mt-4 taxonomy" id=tags-section>Tags</h2><nav class=tags_nav><a href=https://songronghu.github.io/tags/blog/ class="post_tag button button_translucent" title=blog>BLOG
<span class=button_tally>2</span>
</a><a href=https://songronghu.github.io/tags/emacs/ class="post_tag button button_translucent" title=emacs>EMACS
<span class=button_tally>1</span></a></nav></div></section></aside></div></main><svg width="0" height="0" class="hidden"><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter"><path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68.0 01-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043.0-1.924.366-2.643 1.078A3.56 3.56.0 008.766 5.383c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846.0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47.0.929.273 1.705.82 2.388a3.623 3.623.0 002.115 1.291c-.312.08-.641.118-.979.118-.312.0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652.0 002.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422.0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139.0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77.0 001.172-4.892v-.468a7.788 7.788.0 001.84-1.921 8.142 8.142.0 01-2.11.593z"/></symbol><symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar"><path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916.0 1e2v352c0 33.084 26.916 60 60 60h392c33.084.0 60-26.916 60-60V1e2c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028.0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028.0 20 8.972 20 20v48z"/><path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github"><path d="M255.968 5.329C114.624 5.329.0 120.401.0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384.0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008.0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992.0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584.0 34.368-.32 62.08-.32 70.496.0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab"><path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6.0L12.3 74.8z"/><path d="M12.3 74.7.5 111c-1 3.2.0 6.8 3 8.8l101.6 74-92.5-119z"/><path d="M105 193.7l-38.6-119h-54l92.7 119z"/><path d="M105 193.7l38.7-119H66.4l38.7 119z"/><path d="M105 193.7l38.7-119H198l-93 119z"/><path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/><path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6.0L198 74.8z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss"><circle cx="3.429" cy="20.571" r="3.429"/><path d="M11.429 24h4.57C15.999 15.179 8.821 8.001.0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"/><path d="M24 24C24 10.766 13.234.0.0.0v4.571c10.714.0 19.43 8.714 19.43 19.429z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h362c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top"><path d="M604.501 440.509 325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298.0 36.323s26.223 10.024 36.222.0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221.0 9.999-10.023 9.999-26.298.0-36.323z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly"><path d="M504.971 239.029 448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c19.851.0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002.0 004e2 320v108c0 19.851-16.149 36-36 36h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c46.318.0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568.0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255.0 24-10.745 24-24S205.255.0 192 0h-44c-46.318.0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568.0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255.0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851.0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002.0 00112 192z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy"><path d="M23 2.75A2.75 2.75.0 0020.25.0H8.75A2.75 2.75.0 006 2.75v13.5A2.75 2.75.0 008.75 19h11.5A2.75 2.75.0 0023 16.25zM18.25 14.5h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5z"/><path d="M8.75 20.5A4.255 4.255.0 014.5 16.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752.0 001 5.25v16A2.752 2.752.0 003.75 24h12a2.752 2.752.0 002.75-2.75v-.75z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme"><path d="M284.286 256.002 506.143 34.144c7.811-7.811 7.811-20.475.0-28.285-7.811-7.81-20.475-7.811-28.285.0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285.0-7.81 7.811-7.811 20.475.0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475.0 28.285a19.938 19.938.0 0014.143 5.857 19.94 19.94.0 0014.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475.0-28.285L284.286 256.002z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu"><path d="M492 236H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954.0 96s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram"><path d="M12 2.163c3.204.0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849.0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204.0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849.0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741.0 8.333.014 7.053.072c-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948s.014 3.668.072 4.948c.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24s3.668-.014 4.948-.072c4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948s-.014-3.667-.072-4.947c-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403.0-6.162 2.759-6.162 6.162S8.597 18.163 12 18.163s6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zM12 16c-2.209.0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796.0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795.0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="youtube"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23.0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23.0C23.512 20.55 23.971 18.196 24 12c-.029-6.185-.484-8.549-4.385-8.816zM9 16V8l8 3.993L9 16z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow"><path d="M21 27v-8h3v11H0V19h3v8h18z"/><path d="M17.1.2 15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8 13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing"><path d="M18.188.0c-.517.0-.741.325-.927.66.0.0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211.0.375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016.0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894.0 21.686.0h-3.498zM3.648 4.74c-.211.0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016.0.021L1.86 16.051c-.099.188-.093.381.0.529.085.142.239.234.45.234h3.461c.518.0.766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord"><path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527.41542 45.5603.39851 45.468.440769 45.4204.525289 44.7963 1.6353 44.105 3.0834 43.6209 4.2216c-5.4572-.817-10.8864-.817-16.2317.0C26.905 3.0581 26.1886 1.6353 25.5617.525289 25.5141.443589 25.4218.40133 25.3294.41542c-5.071.87338-9.9237 2.40318-14.4518 4.48238C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795 1.57795 18.7309-.943561 32.1443.293408 45.3914.299005 45.4562.335386 45.5182.385761 45.5576 6.45866 50.0174 12.3413 52.7249 18.1147 54.5195 18.2071 54.5477 18.305 54.5139 18.3638 54.4378 19.7295 52.5728 20.9469 50.6063 21.9907 48.5383 22.0523 48.4172 21.9935 48.2735 21.8676 48.2256 19.9366 47.4931 18.0979 46.6 16.3292 45.5858 16.1893 45.5041 16.1781 45.304 16.3068 45.2082 16.679 44.9293 17.0513 44.6391 17.4067 44.3461 17.471 44.2926 17.5606 44.2813 17.6362 44.3151c11.6196 5.3051 24.1992 5.3051 35.6817.0C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433 53.9057 44.6363 54.2779 44.9293 54.6529 45.2082 54.7816 45.304 54.7732 45.5041 54.6333 45.5858c-1.7687 1.0339-3.6074 1.9073-5.5412 2.637C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383c1.0662 2.0651 2.2836 4.0316 3.6241 5.8967C52.6519 54.5139 52.7526 54.5477 52.845 54.5195c5.8014-1.7946 11.684-4.5021 17.7569-8.9619C70.6551 45.5182 70.6887 45.459 70.6943 45.3942 72.1747 30.0791 68.2147 16.7757 60.1968 4.9823 60.1772 4.9429 60.1437 4.9147 60.1045 4.8978zM23.7259 37.3253c-3.4983.0-6.3808-3.2117-6.3808-7.156s2.8266-7.156 6.3808-7.156c3.5821.0 6.4367 3.2399 6.3807 7.156.0 3.9443-2.8266 7.156-6.3807 7.156zm23.5919.0c-3.4982.0-6.3807-3.2117-6.3807-7.156s2.8265-7.156 6.3807-7.156c3.5822.0 6.4367 3.2399 6.3808 7.156.0 3.9443-2.7986 7.156-6.3808 7.156z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon"><path fill="#fff" d="m15.054695 9.8859583c-.22611 1.1632697-2.02517 2.4363497-4.09138 2.6830797-1.0774504.12856-2.1382704.24673-3.2694704.19484-1.84996-.0848-3.30971-.44157-3.30971-.44157.0.1801.0111.35157.0333.51194.24051 1.82571 1.81034 1.93508 3.29737 1.98607 1.50088.0514 2.8373104-.37004 2.8373104-.37004l.0617 1.35686s-1.0498104.56374-2.9199404.66742c-1.03124.0567-2.3117-.0259-3.80308-.42069-3.23454998-.85613-3.79081998-4.304-3.87592998-7.8024197-.026-1.03871-.01-2.01815-.01-2.83732.0-3.57732 2.34385998-4.62587996 2.34385998-4.62587996 1.18184-.54277 3.20976-.77101 5.318-.7882499985409h.0518C9.8267646.01719834 11.856025.24547834 13.037775.78824834c0 0 2.34377 1.04855996 2.34377 4.62587996.0.0.0294 2.63937-.32687 4.47183"/><path fill="#000" d="m12.616925 5.6916583v4.3315297h-1.71607V5.8189683c0-.88624-.37289-1.33607-1.1187604-1.33607-.82467.0-1.23799.53361-1.23799 1.58875v2.30122h-1.70594v-2.30122c0-1.05514-.4134-1.58875-1.23808-1.58875-.74587.0-1.11876.44983-1.11876 1.33607v4.2042197h-1.71607V5.6916583c0-.88527.22541-1.58876.67817-2.10922.46689-.52047 1.07833-.78727 1.83735-.78727.87816.0 1.54317.33752 1.98288 1.01267l.42744.71655.42753-.71655c.43961-.67515 1.10463-1.01267 1.9828704-1.01267.75893.0 1.37037.2668 1.83735.78727.45268.52046.67808 1.22395.67808 2.10922"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" id="bluesky"><path d="m135.72 44.03C202.216 93.951 273.74 195.17 3e2 249.49c26.262-54.316 97.782-155.54 164.28-205.46C512.26 8.009 590-19.862 590 68.825c0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-.0174-2.9357-1.1937.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07.0-88.687 77.742-60.816 125.72-24.795z"/><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="ko-fi"><path fill="#fff" d="M4.5 9.8527H32.7947a0 0 0 010 0v19.225a9.07 9.07.0 01-9.07 9.07H13.57a9.07 9.07.0 01-9.07-9.07V9.8527a0 0 0 010 0z"/><path fill="#000" d="M12.197 25.9493l6.45 6.45 6.45-6.45a8.2 8.2.0 002.4016-5.798h0a4.5082 4.5082.0 00-4.212-4.5459 4.4262 4.4262.0 00-4.64 4.4209 4.4261 4.4261.0 00-4.64-4.4209 4.5082 4.5082.0 00-4.212 4.5459h0a8.2 8.2.0 002.4024 5.798z"/><path fill="#fff" d="M32.7947 9.8527H35.73a7.77 7.77.0 010 15.5394H32.7947"/></svg></symbol></svg><footer class=footer><div class="footer_inner wrap pale"><img src=https://songronghu.github.io/icons/apple-touch-icon.png class="icon icon_2 transparent" alt="My Blog"><p>Copyright&nbsp;<span class=year></span>&nbsp;MY BLOG. All Rights Reserved</p><a class=to_top href=#documentTop><svg class="icon"><title>to-top</title><use xlink:href="#to-top"/></svg></a></div></footer><script type=text/javascript src=https://songronghu.github.io/en/js/bundle.9f41e8957746dbf4000a4ae0202eee34b28fe11dddf9f34fa79df3b517193fdf6bcc548f3b5eebbd24d9fdb6a28b171d1eb864b71df27f3466ad183206aa8af4.js integrity="sha512-n0HolXdG2/QACkrgIC7uNLKP4R3d+fNPp53ztRcZP99rzFSPO17rvSTZ/baiixcdHrhktx3yfzRmrRgyBqqK9A==" crossorigin=anonymous></script></body></html>