<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>My Blog</title><link>https://songronghu.github.io/</link><description>Recent content on My Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 Dec 2025 12:07:25 +0800</lastBuildDate><atom:link href="https://songronghu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP 接收报文 流程分析</title><link>https://songronghu.github.io/posts/2025-12-04/</link><pubDate>Thu, 04 Dec 2025 12:07:25 +0800</pubDate><guid>https://songronghu.github.io/posts/2025-12-04/</guid><description>
&lt;h2 id="tcp接收报文流程分析"&gt;TCP接收报文流程分析&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt=""
class="image_figure image_internal image_unprocessed"
src="https://songronghu.github.io/images/2025-12-04_2025_12_19_12_05_37.png"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;a href="https://www.taohui.pub/2016/01/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3-tcp%E6%B6%88%E6%81%AF%E7%9A%84%E6%8E%A5%E6%94%B6/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"&gt;引用：TCP消息的接收&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="一-整体流程概览"&gt;一、整体流程概览&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;服务器端接收 TCP 报文&lt;/strong&gt; 的内核逻辑。 大体过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;网卡收到报文&lt;/strong&gt; → 交给内核协议栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP 层&lt;/strong&gt; 检查序列号是否在期望窗口内。&lt;/li&gt;
&lt;li&gt;根据顺序插入不同的队列：
&lt;ul&gt;
&lt;li&gt;正常顺序 → 放入 &lt;code&gt;receive_queue&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;超前包（乱序）→ 放入 &lt;code&gt;out_of_order_queue&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当缺失的包到达后，触发 reordering，把 &lt;code&gt;out_of_order&lt;/code&gt; 中的连续数据搬到
&lt;code&gt;receive_queue&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;用户进程调用 &lt;code&gt;recv()&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;如果数据已在 &lt;code&gt;receive_queue&lt;/code&gt; → 直接拷贝到用户缓冲区；&lt;/li&gt;
&lt;li&gt;如果没有数据 → 阻塞等待或立即返回（非阻塞）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="二-四个队列的作用与位置"&gt;二、四个队列的作用与位置&lt;/h3&gt;
&lt;h4 id="backlog-队列"&gt;1️⃣ backlog 队列&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt; ：保存还未被应用层 &lt;code&gt;accept()&lt;/code&gt; 的连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位置&lt;/strong&gt; ：属于 &lt;code&gt;listen socket&lt;/code&gt; ，即服务器监听套接字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说明&lt;/strong&gt; ：
&lt;ul&gt;
&lt;li&gt;TCP 三次握手完成后，内核把新连接放入 backlog 队列；&lt;/li&gt;
&lt;li&gt;应用层调用 &lt;code&gt;accept()&lt;/code&gt; 时，从 backlog 取出一个连接生成新的
&lt;code&gt;established socket&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;一旦生成，接下来的数据接收就交给该新 socket
的接收队列体系（即下面几个队列）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所以 backlog 队列不存放数据包，只存放“还未被 accept 的连接请求”。&lt;/p&gt;</description></item><item><title>TCP 发送数据 核心流程</title><link>https://songronghu.github.io/posts/2025-12-03/</link><pubDate>Wed, 03 Dec 2025 22:36:55 +0800</pubDate><guid>https://songronghu.github.io/posts/2025-12-03/</guid><description>
&lt;h2 id="mss-作用解析"&gt;MSS 作用解析&lt;/h2&gt;
&lt;h3 id="mss-是什么"&gt;MSS 是什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MSS（Maximum Segment Size，最大报文段长度）&lt;/strong&gt;
是 &lt;strong&gt;TCP 协议层&lt;/strong&gt; 中一个非常关键的参数，用来表示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个 TCP 报文段（Segment）中能携带的最大数据量（不包括 TCP/IP 头部）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看一张逻辑关系图：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-nil" data-lang="nil"&gt;┌──────────────────────────────────────────────┐
│ IP 数据包（MTU，一般是 1500 字节） │
├──────────────────────────────────────────────┤
│ IP Header (20 bytes) │
├──────────────────────────────────────────────┤
│ TCP Header (20 bytes) │
├──────────────────────────────────────────────┤
│ TCP Data (MSS) │
└──────────────────────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关系公式如下：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-nil" data-lang="nil"&gt;
MSS = MTU - IP 头长度 - TCP 头长度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常以太网的 MTU 是 &lt;strong&gt;1500 字节&lt;/strong&gt; ，
那么：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-nil" data-lang="nil"&gt;MSS = 1500 - 20（IP 头） - 20（TCP 头） = 1460 字节
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="mss-的作用"&gt;MSS 的作用&lt;/h3&gt;
&lt;h4 id="1-避免-ip-分片-fragmentation"&gt;1 避免 IP 分片（Fragmentation）&lt;/h4&gt;
&lt;p&gt;如果 TCP 报文太大，超过底层网络的 &lt;strong&gt;MTU&lt;/strong&gt; ，
IP 层就必须进行 &lt;strong&gt;分片（Fragmentation）&lt;/strong&gt; 。
分片容易导致：&lt;/p&gt;</description></item><item><title>使用hugo搭建博客</title><link>https://songronghu.github.io/posts/deploy_personal_blog/</link><pubDate>Thu, 18 Sep 2025 01:06:08 +0800</pubDate><guid>https://songronghu.github.io/posts/deploy_personal_blog/</guid><description>
&lt;h2 id="下载hugo安装包"&gt;下载hugo安装包&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/gohugoio/hugo/releases"&gt;https://github.com/gohugoio/hugo/releases&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="解压并移动到-usr-local-bin"&gt;解压并移动到/usr/local/bin&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd ~/Downloads
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tar xvf hugo_extended_0.150.0_Linux-64bit.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo mv hugo /usr/local/bin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="创建博客目录并下载主题"&gt;创建博客目录并下载主题&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;hugo new site myblog
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd myblog
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git init
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git submodule add https://github.com/chipzoller/hugo-clarity themes/hugo-clarity
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="创建first-blog-dot-md"&gt;创建first-blog.md&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;hugo new posts/first-blog.md
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="修改draft默认配置"&gt;修改draft默认配置&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-nil" data-lang="nil"&gt;vim archetypes/default.md
+++
date = &amp;#39;{{ .Date }}&amp;#39;
draft = false
title = &amp;#39;{{ replace .File.ContentBaseName &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#39;
+++
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="建立blog仓库-push后借助github-action和github-page自动发布自己的博客"&gt;建立blog仓库，push后借助github Action和github Page自动发布自己的博客&lt;/h2&gt;
&lt;h3 id="建立page仓库-此仓库名必须是-username-dot-github-dot-io"&gt;建立Page仓库，此仓库名必须是：username.github.io&lt;/h3&gt;
&lt;h4 id="生成personal-token"&gt;生成personal_token&lt;/h4&gt;
&lt;p&gt;访问github依次打开设置：Settings-&amp;gt;Developer Settings-&amp;gt; Personal access tokens -&amp;gt; tokens (classic)，
generate-new-token，需要有repo权限&lt;/p&gt;
&lt;h4 id="创建repository-secret"&gt;创建repository secret&lt;/h4&gt;
&lt;p&gt;打开blog仓库，依次点击Settings-&amp;gt;Secrets and variable-&amp;gt; Actions -&amp;gt; Secrets，点击New repository Secrets来创建personal_token, 输入名字为PERSONAL_TOKEN， 值为上一步生成的api_token,最后点击保存。&lt;/p&gt;</description></item><item><title>我的第一篇博客</title><link>https://songronghu.github.io/posts/my-first-blog/</link><pubDate>Sun, 14 Sep 2025 07:28:23 +0800</pubDate><guid>https://songronghu.github.io/posts/my-first-blog/</guid><description>
&lt;h2 id="2025-09-14"&gt;2025-09-14&lt;/h2&gt;
&lt;p&gt;a happy day!
so cool&lt;/p&gt;</description></item></channel></rss>